#pragma kernel GOL

struct Cell
{
    int state;
};

uint size;
bool loop;
StructuredBuffer<Cell> gridBuffer;
RWStructuredBuffer<int> nextgridBuffer;

int CountNeighboursWithState(int idx, int idy, int state, bool loop)
{
    int count = 0;
    for (int i = -1; i < 2; i++)
    {
        for (int j = -1; j < 2; j++)
        {
            int row = idx + i;
            int col = idy + j;

            if (loop)
            {
                row = (row + size) % size;
                col = (col + size) % size;
            }

            if (row < 0 || (uint)row > size - 1)
                continue;
            if (col < 0 || (uint)col > size - 1)
                continue;

            count += gridBuffer[row * size + col].state == state ? 1 : 0;
        }
    }
    count -= gridBuffer[idx * size + idy].state == state ? 1 : 0;
    return count;
}

[numthreads(1,1,1)]
void GOL(uint3 id : SV_DispatchThreadID)
{
    int i = id.y;
    int j = id.x;
    int idx = i * size + j;

    //Rules
    int state = gridBuffer[idx].state;
    
    int On_neighbours = CountNeighboursWithState(i, j, 1, loop);

    if (state == 0 && On_neighbours == 3)
    {
        nextgridBuffer[idx] = 1;
    }
    else if (state == 1 && (On_neighbours != 2 && On_neighbours != 3))
    {
        nextgridBuffer[idx] = 0;
    }
    else
    {
        nextgridBuffer[idx] = state;
    }
}